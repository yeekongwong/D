# Redis

---

## 1.Redis场景
> + 缓存数据
+ 队列
## 2.特点
> 速度很快，因为基于内存存储数据，而且是单线程的。为何不多线程，因为读写都是基于内存，几乎无io操作，自然的CPU不是瓶颈，更多是内存和网速，没必要用多线程。相反用多线程，还要有上下文切换时间，速度比单线程更慢。
## 3.持久化AOF
> + 通过保存redis服务器所执行的写命令来记录数据库状态
+ 通过命令追加，文件写入，文件同步来实现
+ 重写
## 4.持久化RDB
> SAVE 服务器进程保存，会阻塞
BSAVE 子进程保存 不会阻塞
经过压缩的二进制文件
不同类型的键值对保存格式不一样

## 5-1.复制 - 旧版
> + 实现方式：
 - 同步 将主服务器全部同步到从服务器
 - 命令传播 当主从服务器数据不一致时，主服务器会将造成不一致的命令发给从服务器让从重新执行
+ 上述二种方式都是 从服务器向主服务器发送sync命令
+ 缺陷：
    - 当主从断了连接之后，重新连接上时，就会重新同步(执行sync的命令)，保证主从数据一致,这种做法很低效。
+ sync命令过程：
    - 从向主发送sync命令
    - 主接收命令后 执行bgsave来生成RDB文件，这个过程会消耗CPU，内存以及磁盘IO资源
    - 主将生成的RDB文件发送给从，会消耗主从服务器大龄的网格资源
    - 接收到RDB文件的从会将RDB载入期间，从阻塞无法处理命令请求。
    - 综上所述，SYNC命令是个极其消耗资源的操作
## 5-2.复制 - 新版
> + 主要使用了psync命令来体态sync来执行复制时的同步操作
> + psync拥有完整重同步(和旧版的初次复制情况的sync命令是基本一样的)和部分重同步(只需要将从服务器缺少的命令发送给从库执行就可以了)
> + 部分重同步实现方式：
    - 主从服务器的复制偏移量 - 用来对主从数据是否一致
    - 主服务器的复制积压缓冲区 - 保留最近传播的写命令，并保存每个队列中每个字节记录相应的复制偏移量。
        - 如果从的偏移量之后的数据还在复制积压缓冲区，那么就进行部门重同步
        - 否则，进行完全冲同步
    - 服务器的运行id - 当从对主初次复制时，主会将运行id给从。当从断了主连接之后重新连上的话，从的运行id会和主相比较
        - 相等，则看看是否需要完全重同步
        - 不相等 则 完全重同步
        




