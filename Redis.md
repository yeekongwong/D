# Redis
---

## 1.Redis场景
> + 缓存数据
+ 排行榜
+ 计数器
+ 消息队列
+ 分布式锁
+ 队列

## 2.特点
> 速度很快，因为基于内存存储数据，而且是单线程的。为何不多线程，因为读写都是基于内存，几乎无io操作，自然的CPU不是瓶颈，更多是内存和网速，没必要用多线程。相反用多线程，还要有上下文切换时间，速度比单线程更慢。

## 3.持久化RDB
> 按照规则定时将数据同步到磁盘,主要使用了快照(snapshot)的方式：
1).自己配置的快照规则
save 900 1 当在900秒内被更改的key数量大于1时，就执行快照
2).SAVE 服务器进程保存，会阻塞客户端的请求
BSAVE 子进程保存 不会阻塞客户端请求
3).执行flushall的时候
清除内存的所有数据，只要第一个规则存在，则就会执行快照
4).执行复制的时候
经过压缩的二进制文件
不同类型的键值对保存格式不一样
优缺点：
1) 可能会存在数据丢失的请求
2）可以最大化redis的性能

## 4.持久化AOF
> 
+ 若同时使用AOF和RDB持久化时，那么当Redis重启时会优先使用AOF文件还原数据。
+ appendonly yes 开启AOF
+ 通过保存redis服务器所执行的写命令来记录数据库状态
+ 同步磁盘过程：通过命令追加，文件写入，文件同步三个步骤来实现；也就是说每次更改数据的时候，aof机制会将命令记录到aof文件，但实际上由于操作系统的缓存机制，数据并没有实时的写入到硬盘,而是进去到硬盘缓存。再通过硬盘缓存机制去刷新保存到文件。但可以进行配置：appendfsync always(每次执行写入都会进行同步)/everysec(默认)/no(有操作系统执行，效率最快但最不安全)
+ 重写:当AOF文件太大时，可以进行压缩。主要是对同一个key进行多次操作后，前面的操作命令是无用的。
+ 加载AOF文件内容时会比rdb慢
优化重写AOF文件的配置：
auto-aof-rewrite-percentage 100 表示当前AOF文件带下超过上一次AOF文件大小的百分之多少的时候会重写；如果没重新则以启动时的AOF文件大小为准
auto-aof-rewrite-min-size 64mb 限制允许重写最小AOF文件大小，也就是小于64mb时不需要重写AOF
+ 当AOF和RDB同时启动时，那么在redis重启时，会优先使用AOF文件来还原数据
+ AOF重写的原理:重写过程中是安全的；在这个过程中，会fork了一个子进程对新的AOF文件进行写入；当客户端有新数据来时，会对新旧的aof文件都会写入。
+ AOF文件损坏时，可以通过redis-check-aof-fix命令

## 5-1.复制 - 旧版
> + 实现方式：
 - 同步 将主服务器全部同步到从服务器
 - 命令传播 当主从服务器数据不一致时，主服务器会将造成不一致的命令发给从服务器让从重新执行
+ 上述二种方式都是 从服务器向主服务器发送sync命令
+ 缺陷：
    - 当主从断了连接之后，重新连接上时，就会重新同步(执行sync的命令)，保证主从数据一致,这种做法很低效。
+ sync命令过程：
    - 从向主发送sync命令
    - 主接收命令后 执行bgsave来生成RDB文件，这个过程会消耗CPU，内存以及磁盘IO资源
    - 主将生成的RDB文件发送给从，会消耗主从服务器大龄的网格资源
    - 接收到RDB文件的从会将RDB载入期间，从阻塞无法处理命令请求。
    - 综上所述，SYNC命令是个极其消耗资源的操作
    
## 5-2.复制 - 新版
> + 主要使用了psync命令来体态sync来执行复制时的同步操作
> + psync拥有完整重同步(和旧版的初次复制情况的sync命令是基本一样的)和部分重同步(只需要将从服务器缺少的命令发送给从库执行就可以了)
> + 部分重同步实现方式：
    - 主从服务器的复制偏移量 - 用来对主从数据是否一致
    - 主服务器的复制积压缓冲区 - 保留最近传播的写命令，并保存每个队列中每个字节记录相应的复制偏移量。
        - 如果从的偏移量之后的数据还在复制积压缓冲区，那么就进行部门重同步
        - 否则，进行完全冲同步
    - 服务器的运行id - 当从对主初次复制时，主会将运行id给从。当从断了主连接之后重新连上的话，从的运行id会和主相比较
        - 相等，则看看是否需要完全重同步
        - 不相等 则 完全重同步

## 6.与mysql一致
> + 读请求，先读缓存，如果没有命中，读数据库，再set回缓存
+ 写请求，先缓存，再数据库(缓存，使用delete，而不是set)
+ 这里主要涉及到了cache miss的概念了。在写请求的时候，如果先缓存时用了set，然后再数据库，会造成数据库老数据，数据不一致，业务无法接受。所以先用delete，让其cache无效，再来写数据库。后续来读该缓存时，就会出现 cache miss的情况而直接去读数据，后面再set回redis缓存。

## 7.问题
> + 缓存雪崩
+ 缓存穿透
+ 缓存预热
+ 缓存更新
+ 缓存降级

## 8.多路复用
> 单线程 io多路复用机制
    用户线程       内核空间
       |      read>    |
       |               |
       |               |
       |      <write   |
       |               |
       |               |
同步阻塞:用户线程发了一个read请求过去到内核空间，内核空间处理完后就返回给用户线程
同步非阻塞:用户线程发了一个read请求过去到内核空间后立刻返回用户线程，然后用户线程不断轮询内核空间，直至内核空间处理完返回
多路复用：基于事件驱动，发起多个socket请求到内核空间，当socket请求允许可以处理了，则有个事件通知socket请求可以处理了。
